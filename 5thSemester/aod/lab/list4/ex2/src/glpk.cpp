#include <iostream>
#include <fstream>
#include <string>

#include "glpk.hpp"

/**
 * Generates GNU MathProg (GMPL) code to solve the MaxFlow problem for the given graph.
 * * @param g   The graph object containing nodes and edges.
 * @param out The output stream (e.g., std::cout or a std::ofstream).
 */
void generate_mathprog(const Graph& g, std::ostream& out) {
    // ==========================================
    // 1. MODEL SECTION
    //    Defines the abstract logic for MaxFlow
    // ==========================================
    
    out << "# =========================================================\n";
    out << "# Maximum Flow Problem - GNU MathProg (GMPL) Model\n";
    out << "# Generated by C++ Graph Exporter\n";
    out << "# =========================================================\n\n";

    out << "/* --- SETS AND PARAMETERS --- */\n";
    out << "set V;                       # Set of all nodes in the graph\n";
    out << "set E within V cross V;      # Set of directed edges (arcs)\n";
    // out << "param Capacity{E} >= 0;      # Capacity for each edge\n";
    out << "param Source symbolic in V;  # The Source node index\n";
    out << "param Sink symbolic in V;    # The Sink node index\n\n";

    out << "/* --- DECISION VARIABLES --- */\n";
    out << "/* Flow on edge (u,v). Must be non-negative and cannot exceed Capacity */\n";
    // out << "var Flow{(u,v) in E} >= 0, <= Capacity[u,v];\n\n";
    out << "var Flow{(u,v) in E} >= 0, <= 1;\n\n";

    out << "/* --- OBJECTIVE FUNCTION --- */\n";
    out << "/* We want to maximize the total flow leaving the Source */\n";
    out << "maximize Total_Flow:\n";
    out << "    sum {(Source, v) in E} Flow[Source, v];\n\n";

    out << "/* --- CONSTRAINTS --- */\n";
    out << "/* Flow Conservation: Total Inflow == Total Outflow for all nodes except Source and Sink */\n";
    out << "subject to Conservation {u in V diff {Source, Sink}}:\n";
    out << "    sum {(v,u) in E} Flow[v,u] = sum {(u,w) in E} Flow[u,w];\n\n";

    // ==========================================
    // 2. DATA SECTION
    //    Populates the sets with actual Graph data
    // ==========================================
    
    out << "data;\n\n";

    out << "/* --- GRAPH TOPOLOGY --- */\n";
    // Define Source (Node 0) and Sink (Last Node)
    out << "param Source := 0;\n";
    out << "param Sink := " << (g.adj.size() - 1) << ";\n\n";

    // Define Set V (Nodes)
    out << "# List of all nodes (indices)\n";
    out << "set V :=";
    for (std::size_t i = 0; i < g.adj.size(); ++i) {
        if (i % 20 == 0) out << "\n  "; // formatting for readability
        out << i << " ";
    }
    out << ";\n\n";

    // Define Edges
    out << "# Edge definitions: u v\n";
    out << "# Note: Only forward edges (capacity > 0) are included.\n";
    out << "set E :=\n";
    
    for (std::size_t u = 0; u < g.adj.size(); ++u) {
        for (const auto& edge : g.adj[u]) {
            if (edge.capacity > 0) {
                out << "  " << u << " " << edge.to << "\n";
            }
        }
    }
    out << ";\n\n";

    out << "end;\n";
}